## 线程安全 
- 1、为什么要线程安全 
- 2、自旋锁和互斥锁
- 3、锁的类型
    -1、OSSpinLock
    - 2、os_unfair_lock
    - 3、pthread_mutex
    - 4、dispatch_semaphore
    - 5、dispatch_queue(DISPATCH_QUEUE_SERIAL)
    - 6、NSLock
    - 7、NSRecursiveLock
    - 8、NSCondition
    - 9、NSConditionLock
    - 10、@synchronized
    - 11、pthread_rwlock
    - 12、dispatch_barrier_async
    - 13、atomic



### 为什么要线程安全 

多个线程访问同一块资源的时候，很容易引发数据混乱问题。
一个大家都喜欢拿来举例子的就是`买票demo`，今天我使用这个案例
`假设有100张票，同时开5个窗口买票，5个窗口买票，我们来看看结果`

```
//卖票演示
- (void)ticketTest{
self.ticketsCount = 50;
dispatch_queue_t queue = dispatch_get_global_queue(0, 0);

for (NSInteger i = 0; i < 5; i++) {
dispatch_async(queue, ^{
for (int i = 0; i < 10; i++) {
[self sellingTickets];
}
});
}

}
//卖票
- (void)sellingTickets{
int oldMoney = self.ticketsCount;
sleep(.2);
oldMoney -= 1;
self.ticketsCount = oldMoney;

NSLog(@"当前剩余票数-> %d", oldMoney);
}
```

![线程安全1](https://github.com/SunshineBrother/JHBlog/blob/master/iOS知识点/多线程/线程安全1.png)


正常情况下我有50张票，然后卖了50次，剩余票数应该是0，但是打印结果竟然是3，所以这里就存在了线程安全问题。

**出现线程安全的原因**


![线程安全2](https://github.com/SunshineBrother/JHBlog/blob/master/iOS知识点/多线程/线程安全2.png)

出现线程安全的原因就是在同一个时间，多个线程同时读取一个值，像线程A和B同时读取了当前票数为10，等于是卖了两张票，但是总票数其实就减少了一张。

**解决方法**

使用线程同步技术，按照预定的先后次序依次进行，常见的线程同步技术就是`加锁`


![线程安全3](https://github.com/SunshineBrother/JHBlog/blob/master/iOS知识点/多线程/线程安全3.png)












[关于 @synchronized，这儿比你想知道的还要多](http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/)

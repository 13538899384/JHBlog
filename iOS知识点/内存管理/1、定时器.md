## 定时器
有三种常见定时器
- 1、NSTimer
- 2、CADisplayLink
- 3、GCD


**NSTimer**

NSTimer是iOS中最常用的定时器。其通过Runloop来实现，一般情况下比较准确。但是当前循环耗时操作较多时，会出现延迟问题。同时，也受所加入的RunLoop的RunLoopMode影响。

```
/// 构造并开启(启动NSTimer本质上是将其加入RunLoop中)
// "scheduledTimer"前缀的为自动启动NSTimer的，如:
+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block

/// 构造但不开启
// "timer"前缀的为只构造不启用的，如:
+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block

//定时器的释放一定要先将其终止，而后才能销毁对象
- (void)invalidate;
//立即执行(fire)
//我们对定时器设置了延时之后，有时需要让它立刻执行，可以使用fire方法:
- (void)fire;
```
简单使用
```
//方法1
self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(doTask) userInfo:nil repeats:YES];

//方法2
self.timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(doTask) userInfo:nil repeats:YES];
[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];
```


**CADisplayLink**

CADisplayLink是基于`屏幕刷新的周期`，所以其一般很准时，每秒刷新60次。其本质也是通过RunLoop，所以不难看出，当RunLoop选择其他模式或被耗时操作过多时，仍旧会造成延迟。


其使用步骤为 `创建CADisplayLink->添加至RunLoop中->终止->销毁`。代码如下

```
self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(doTask)];
[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];

//在dealloc中
// 终止定时器
[disLink invalidate];
// 销毁对象
disLink = nil;
```

同时，由于其是基于屏幕刷新的，所以也度量单位是每帧，其提供了根据屏幕刷新来设置间隔的frameInterval属性，其决定于屏幕刷新多少帧时调用一次该方法，默认为1，即1/60秒调用一次。

如果我们想要计算出每次调用的时间间隔，可以通过frameInterval * duration求出，后者为屏幕每帧间隔的只读属性。

在日常开发中，适当使用CADisplayLink甚至有优化作用。比如对于需要动态计算进度的进度条，由于起进度反馈主要是为了UI更新，那么当计算进度的频率超过帧数时，就造成了很多无谓的计算。如果将计算进度的方法绑定到CADisplayLink上来调用，则只在每次屏幕刷新时计算进度，优化了性能。MBProcessHUB则是利用了这一特性

 
**GCD**

GCD定时器实际上是使用了dispatch源(dispatch source)，dispatch源监听系统内核对象并处理，通过系统级调用，更加精准

```
/** 创建定时器对象
* para1: DISPATCH_SOURCE_TYPE_TIMER 为定时器类型
* para2-3: 中间两个参数对定时器无用
* para4: 最后为在什么调度队列中使用
*/
_gcdTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0));
/** 设置定时器
* para2: 任务开始时间
* para3: 任务的间隔
* para4: 可接受的误差时间，设置0即不允许出现误差
* Tips: 单位均为纳秒
*/
dispatch_source_set_timer(_gcdTimer, DISPATCH_TIME_NOW, 2.0 * NSEC_PER_SEC, 0.0 * NSEC_PER_SEC);
/** 设置定时器任务
* 可以通过block方式
* 也可以通过C函数方式
*/
dispatch_source_set_event_handler(_gcdTimer, ^{
static int gcdIdx = 0;
NSLog(@"GCD Method: %d", gcdIdx++);
NSLog(@"%@", [NSThread currentThread]);

if(gcdIdx == 5) {
// 终止定时器
dispatch_suspend(_gcdTimer);
}
});
// 启动任务，GCD计时器创建后需要手动启动
dispatch_resume(_gcdTimer);

```
### 内存泄露

我们简单的做一个能够销毁的`viewcontroller`，然后里面写一个`NSTimer`定时器，然后在`dealloc`中销毁定时器。我们发现在我们`viewcontroller`销毁的时候，`dealloc`并没有执行，所以其实使用`dealloc`是存在内存泄漏的。




























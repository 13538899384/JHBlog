## 方法缓存

我们先来整体的看一下结构
![方法缓存](https://github.com/SunshineBrother/JHBlog/blob/master/iOS知识点/RunTime/方法缓存.png)

- 1、class类中只要有`isa指针`、`superClass`、`cache方法缓存`、`bits具体的类信息` 
- 2、`bits & FAST_DATA_MASK` 指向一个新的结构体`Class_rw_t`，里面包含着`methods方法列表`、`properties属性列表`、`protocols协议列表`、`class_ro_t类的初始化信息`等一些类信息


**Class_rw_t**
`Class_rw_t`里面的`methods方法列表`、`properties属性列表`都是二维数组，是**可读可写**的，包含`类的初始内容`，`分类的内容`

![方法缓存1](https://github.com/SunshineBrother/JHBlog/blob/master/iOS知识点/RunTime/方法缓存1.png)

**class_ro_t**

`class_ro_t`里面的baseMethodList，baseProtocols，Ivars，baseProperties是一维数组，是**只读**的，包含类的初始化内容

![方法缓存2](https://github.com/SunshineBrother/JHBlog/blob/master/iOS知识点/RunTime/方法缓存2.png)


**method_t**

`method_t`是对方法的封装
```
struct method_t{
SEL name;//函数名
const char *types;//编码（返回值类型，参数类型）
IMP imp;//指向函数的指针（函数地址）
}
```

**IMP**

IMP代表函数的具体实现
```
typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); 
```
第一个参数是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器(selector)

**SEL**

SEL代表方法名，一般叫做选择器，底层结构跟`char *`类似
- 可以通过`@selector()`和`sel_registerName()`获得
- 可以通过`sel_getName()`和`NSStringFromSelector()`转成字符串
- 不同类中相同名字的方法，所对应的方法的选择器是相同的
- 具体实现`typedef struct objc_selector *SEL`

**types**

types包含了函数返回值，参数编码的字符串

结构为：返回值  参数1 参数2...参数N

iOS中提供了一个叫做`@encode`的指令，可以将具体的类型表示成字符串编码

![方法缓存3](https://github.com/SunshineBrother/JHBlog/blob/master/iOS知识点/RunTime/方法缓存3.png)



### 方法缓存
Class内部结构中有一个方法缓存`cache_t`，用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度。


![方法缓存4](https://github.com/SunshineBrother/JHBlog/blob/master/iOS知识点/RunTime/方法缓存4.png)

`cache_t`结构体里面有三个元素
- `buckets` 散列表，是一个数组，数组里面的每一个元素就是一个`bucket_t`,`bucket_t`里面存放两个
    - `_key` SEL作为key
    - `_imp` 函数的内存地址

- `_mask` 散列表的长度
- `_occupied`已经缓存的方法数量


**为什么会用到方法缓存**

 ![OC对象的分类2](https://github.com/SunshineBrother/JHBlog/blob/master/iOS知识点/images/OC对象的分类2.png)

这张图片是我们

















## 方法缓存

我们先来整体的看一下结构
![方法缓存](https://github.com/SunshineBrother/JHBlog/blob/master/iOS知识点/RunTime/方法缓存.png)

- 1、class类中只要有`isa指针`、`superClass`、`cache方法缓存`、`bits具体的类信息` 
- 2、`bits & FAST_DATA_MASK` 指向一个新的结构体`Class_rw_t`，里面包含着`methods方法列表`、`properties属性列表`、`protocols协议列表`、`class_ro_t类的初始化信息`等一些类信息


**Class_rw_t**
`Class_rw_t`里面的`methods方法列表`、`properties属性列表`都是二维数组，是**可读可写**的，包含`类的初始内容`，`分类的内容`

![方法缓存1](https://github.com/SunshineBrother/JHBlog/blob/master/iOS知识点/RunTime/方法缓存1.png)

**class_ro_t**

`class_ro_t`里面的baseMethodList，baseProtocols，Ivars，baseProperties是一维数组，是**只读**的，包含类的初始化内容

![方法缓存2](https://github.com/SunshineBrother/JHBlog/blob/master/iOS知识点/RunTime/方法缓存2.png)


**method_t**

`method_t`是对方法的封装
```
struct method_t{
SEL name;//函数名
const char *types;//编码（返回值类型，参数类型）
IMP imp;//指向函数的指针（函数地址）
}
```

**IMP**

IMP代表函数的具体实现
```
typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); 
```
第一个参数是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器(selector)

**SEL**

SEL代表方法名，一般叫做选择器，底层结构跟`char *`类似
- 可以通过`@selector()`和`sel_registerName()`获得
- 可以通过`sel_getName()`和`NSStringFromSelector()`转成字符串
- 不同类中相同名字的方法，所对应的方法的选择器是相同的
- 具体实现`typedef struct objc_selector *SEL`

**types**

types包含了函数返回值，参数编码的字符串

结构为：返回值  参数1 参数2...参数N

iOS中提供了一个叫做`@encode`的指令，可以将具体的类型表示成字符串编码

![方法缓存3](https://github.com/SunshineBrother/JHBlog/blob/master/iOS知识点/RunTime/方法缓存3.png)






























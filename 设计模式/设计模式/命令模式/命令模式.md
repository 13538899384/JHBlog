## 命令模式

> 命令模式（Command Pattern）:在软件系统中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。这就是命令模式


![命令模式](https://github.com/SunshineBrother/JHBlog/blob/master/设计模式/设计模式/命令模式/命令模式.png)

- Command：定义命令的接口，声明执行的方法。
- ConcreteCommand：命令接口实现对象，是抽象的实现；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。
- Receiver：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。
- Invoker：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。
- Client：创建具体的命令对象，并且设置命令对象的接收者


### 案例

我们这里来举一个例子：烧烤摊VS烧烤店

**烧烤摊**

有一家烧烤摊，有十几个人排队，有的人要5串烤羊肉串，有的人要10串烤面筋，有的人要1串烤羊腰，有的人要几串烤鸡翅，一会又有人不要什么了等等。一会烤串大叔就记错了，不知道谁都要了什么

**烧烤店**

在烧烤店有一个服务员专门拿一个账单来记录每一个客人都要了什么，退了什么。然后把相关菜单命令给厨房厨师。这样不论有多少的客人，都不会出现差错


烧烤摊中厨师和客户紧耦合，容易出错；烧烤店厨师和客户由命令之间连接，解除了紧耦合关系。


我们这里的烧烤店就仅仅烤羊肉和烤鸡翅

**1、定义Receiver**

Receiver是厨师，他有两个方法，烤多少羊肉串，烤多少鸡翅
























































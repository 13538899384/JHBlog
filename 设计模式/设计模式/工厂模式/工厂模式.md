## 工厂模式

工厂模式一般可以细分为三类
- 1、简单工厂：简单工厂不是一个模式，而是一种编程习惯，提供一个创建对象实例的功能，而无需关心具体实现。被创建的类型可以使接口、抽象类、具体类。
- 2、工厂模式：要依赖抽象，不要依赖具体
- 3、抽象工厂模式：提供一个创建一系列相关或者相互依赖的接口，而无需依赖具体类。

为了让大家更加清楚的理解这三种模式的不同，我会先使用一个抽象的案例，然后在使用一个iOS开发中的案例做对比，方便理解

### 简单工厂

简单工厂模式(Simple Factory Pattern)：专门定义一个类（工厂类）来负责创建其他类的实例。可以根据创建方法的参数来返回不同类的实例，被创建的实例通常都具有共同的父类。

`总结来说，其实就是把一大堆的if-else判断由业务层，放到了工厂类里面`


#### UML结构图

![简单工厂](https://github.com/SunshineBrother/JHBlog/blob/master/设计模式/设计模式/工厂模式/简单工厂.png)


简单工厂模式的结构比较简单

- 1、工厂：工厂负责实现创建所有产品实例的逻辑
- 2、具体产品：工厂所创建的所有产品对象类，它以自己的方式来实现其共同父类声明的接口


#### 案例

一个店铺中售卖不同品牌的手机：华为手机，小米手机，苹果手机

**场景分析**

这个场景我们可以使用简单工厂来设计
- 1、工厂：Phone，手机工厂类
- 2、具体产品：华为手机，小米手机，苹果手机

UML结构图

![手机工厂](https://github.com/SunshineBrother/JHBlog/blob/master/设计模式/设计模式/工厂模式/手机工厂.png)



**代码实现**

工厂类`PhoneFactory`

```
- (PhoneFactory *)sellPhone:(NSString *)type{
if ([type isEqualToString:@"IPhone"]) {
IPhone *phone = [IPhone new];
[phone sellPhone];
return phone;
}else if ([type isEqualToString:@"MIPhone"]){
MIPhone *phone = [MIPhone new];
[phone sellPhone];
return phone;
}else if ([type isEqualToString:@"HWPone"]){
HWPhone *phone = [HWPhone new];
[phone sellPhone];
return phone;
}
return nil;
}
```

苹果手机类`IPhone`
```
- (void)sellPhone{
NSLog(@"售卖苹果手机");
}
```

小米手机类`MIPhone`

```
- (void)sellPhone{
NSLog(@"售卖小米手机");
}
```

华为手机类`HWPhone`
```
- (void)sellPhone{
NSLog(@"售卖华为手机");
}
```


客户端调用
```
PhoneFactory *faceory = [PhoneFactory new];
[faceory sellPhone:@"IPhone"];
```


这时候我们运行打印
```
售卖苹果手机
```

 

**实践案例**

这里我来举一个iOS中`tableView`的例子：假设我们一个`tableView`里面有3个或者更多的`cell`需要处理。

如果我们就是简单的代码堆积
```
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
if (indexPath.row == 0) {

OneCell *cell = [tableView dequeueReusableCellWithIdentifier:@"OneCell"];
[cell configUI];  //不同样式的Cell所展示的UI各不相同，由于是Demo样例，这里并未配置相关数据源
return cell;
}else if (indexPath.row == 1) {

TwoCell *cell = [tableView dequeueReusableCellWithIdentifier:@"TwoCell"];
[cell configUI];
return cell;
}else if (indexPath.row == 2) {

ThreeCell *cell = [tableView dequeueReusableCellWithIdentifier:@"ThreeCell"];
[cell configUI];
return cell;
}
return nil;
}

```
随着需求的迭代，我们后期可能会增加更多样式的Cell，此时我们就需要变更这部分的代码。增加与之对应的else if条件判断，代码将变得越来越长。同时，在更加复杂的场景下，我们并不能保证调整原有代码以后，之前功能不受影响。我们将投入更多的时间进行原有代码功能的回归，这是我们不希望发生的。

这个时候我们就可以使用简单工厂模式。

创建简单工厂`FactoryCell`
```
+ (UITableViewCell *)configUI:(NSInteger)tag withTableView:(UITableView *)tableView{
if (tag == 0) {

OneCell *cell = [tableView dequeueReusableCellWithIdentifier:@"OneCell"];
[cell configUI];  //不同样式的Cell所展示的UI各不相同，由于是Demo样例，这里并未配置相关数据源
return cell;
}else if (tag == 1) {

TwoCell *cell = [tableView dequeueReusableCellWithIdentifier:@"TwoCell"];
[cell configUI];
return cell;
}else if (tag == 2) {

ThreeCell *cell = [tableView dequeueReusableCellWithIdentifier:@"ThreeCell"];
[cell configUI];
return cell;
}

return nil;
}

```

在`UITableView`的代理方法中调用，这个时候`UITableViewCell`变清爽的好多。
```
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{

return [FactoryCell configUI:indexPath.row withTableView:tableView];
}
```




**优点**

 客户端只需要给工厂类传入一个正确的（约定好的）参数，就可以获取你所需要的对象，而不需要知道其创建细节，一定程度上减少系统的耦合

**缺点**

如果我们要是在添加`Cell`，那么我们就需要修改`FactoryCell`的方法，违反了开闭原则。

简单来说就是违反了依赖倒置原则，让高层组件client依赖于底层组件。违反这个原则的后果就是一旦底层组件改动，那么高层组件也就必须改动，违反了开闭原则。


> 简单工厂的本质：选择实现


**何时使用简单工厂**

- 1、想完全封装隔离具体实现
    让外部只能通过抽象类或者接口来操作，上面的例子中，就是只能操作`FactoryCell`，而不能操作具体类。此时可以使用简单工厂，让客户端通过简单工厂来选择创建具体的类，不需要创建的具体过程。
- 2、想把创建对象的职责集中管理起来
    一个简单工厂可以创建许多相关或者不相关的对象，所以可以把对象的创建集中到简单工厂来集中管理。
 


#### 工厂模式

工厂方法模式(Factory Method Pattern)又称为工厂模式，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，即通过不同的工厂子类来创建不同的产品对象。

工厂方法模式的适用场景与简单工厂类似，都是创建数据和行为比较类似的对象。但是和简单工厂不同的是：在工厂方法模式中，因为创建对象的责任移交给了抽象工厂的子类，因此客户端需要`知道其所需产品所对应的工厂子类`，而不是简单工厂中的参数


工厂模式主要包含
- 1、抽象工厂（Abstract Factory）：抽象工厂负责声明具体工厂的创建产品的接口。
- 2、具体工厂（Concrete Factory）：具体工厂负责创建产品。
- 3、具体产品（Concrete Product）：具体产品是工厂所创建的所有产品对象类，它以自己的方式来实现其共同父类声明的接口。



![工厂模式](https://github.com/SunshineBrother/JHBlog/blob/master/设计模式/设计模式/工厂模式/工厂模式.png)

这对那个卖手机的案列我们新的UML图


![工厂模式1](https://github.com/SunshineBrother/JHBlog/blob/master/设计模式/设计模式/工厂模式/工厂模式1.png)


`通过工厂模式定义我们知道，工厂模式主要是把对象的创建延迟到子类执行`

抽象工厂PhoneFactory
```
- (void)sellPhone{
@throw ([NSException exceptionWithName:@"继承错误" reason:@"子类必须重写该方法" userInfo:nil]);
}
```

苹果华为小米分别继承自`PhoneFactory`类，然后实现`sellPhone`
```
- (void)sellPhone{
NSLog(@"售卖苹果手机");
}
```

其实我们研究发现，这个工厂方法其实和我们iOS中的多态是一样的。














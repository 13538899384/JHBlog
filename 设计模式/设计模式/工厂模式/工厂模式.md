## 工厂模式

工厂模式一般可以细分为三类
- 1、简单工厂：简单工厂不是一个模式，而是一种编程习惯，提供一个创建对象实例的功能，而无需关心具体实现。被创建的类型可以使接口、抽象类、具体类。
- 2、工厂模式：要依赖抽象，不要依赖具体
- 3、抽象工厂模式：提供一个创建一系列相关或者相互依赖的接口，而无需依赖具体类。

为了让大家更加清楚的理解这三种模式的不同，我会先使用一个抽象的案例，然后在使用一个iOS开发中的案例做对比，方便理解

### 简单工厂

简单工厂模式(Simple Factory Pattern)：专门定义一个类（工厂类）来负责创建其他类的实例。可以根据创建方法的参数来返回不同类的实例，被创建的实例通常都具有共同的父类。

`总结来说，其实就是把一大堆的if-else判断由业务层，放到了工厂类里面`

#### UML结构图

![简单工厂](https://github.com/SunshineBrother/JHBlog/blob/master/设计模式/设计模式/工厂模式/简单工厂.png)


简单工厂模式的结构比较简单

- 1、工厂：工厂负责实现创建所有产品实例的逻辑
- 2、具体产品：工厂所创建的所有产品对象类，它以自己的方式来实现其共同父类声明的接口


#### 案例

一个店铺中售卖不同品牌的手机：华为手机，小米手机，苹果手机

**场景分析**

这个场景我们可以使用简单工厂来设计
- 1、工厂：Phone，手机工厂类
- 2、具体产品：华为手机，小米手机，苹果手机

UML结构图

![手机工厂](https://github.com/SunshineBrother/JHBlog/blob/master/设计模式/设计模式/工厂模式/手机工厂.png)



**代码实现**

工厂类`PhoneFactory`

```
- (PhoneFactory *)sellPhone:(NSString *)type{
if ([type isEqualToString:@"IPhone"]) {
IPhone *phone = [IPhone new];
[phone sellPhone];
return phone;
}else if ([type isEqualToString:@"MIPhone"]){
MIPhone *phone = [MIPhone new];
[phone sellPhone];
return phone;
}else if ([type isEqualToString:@"HWPone"]){
HWPhone *phone = [HWPhone new];
[phone sellPhone];
return phone;
}
return nil;
}
```

苹果手机类`IPhone`
```
- (void)sellPhone{
NSLog(@"售卖苹果手机");
}
```

小米手机类`MIPhone`

```
- (void)sellPhone{
NSLog(@"售卖小米手机");
}
```

华为手机类`HWPhone`
```
- (void)sellPhone{
NSLog(@"售卖华为手机");
}
```


客户端调用
```
PhoneFactory *faceory = [PhoneFactory new];
[faceory sellPhone:@"IPhone"];
```


这时候我们运行打印
```
售卖苹果手机
```

**优点**

- 客户端只需要给工厂类传入一个正确的（约定好的）参数，就可以获取你所需要的对象，而不需要知道其创建细节，一定程度上减少系统的耦合

**缺点**

- 简单来说就是违反了依赖倒置原则，让高层组件client依赖于底层组件cpu。违反这个原则的后果就是一旦底层组件改动，那么高层组件也就必须改动，违反了开闭原则。

 

**实践案例**

这里我来举一个iOS中`tableView`的例子：假设我们一个`tableView`里面有3个或者更多的`cell`需要处理。

如果我们就是简单的代码堆积
```
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
if (indexPath.row == 0) {

OneCell *cell = [tableView dequeueReusableCellWithIdentifier:@"OneCell"];
[cell configUI];  //不同样式的Cell所展示的UI各不相同，由于是Demo样例，这里并未配置相关数据源
return cell;
}else if (indexPath.row == 1) {

TwoCell *cell = [tableView dequeueReusableCellWithIdentifier:@"TwoCell"];
[cell configUI];
return cell;
}else if (indexPath.row == 2) {

ThreeCell *cell = [tableView dequeueReusableCellWithIdentifier:@"ThreeCell"];
[cell configUI];
return cell;
}
return nil;
}

```
随着需求的迭代，我们后期可能会增加更多样式的Cell，此时我们就需要变更这部分的代码。增加与之对应的else if条件判断，代码将变得越来越长。同时，在更加复杂的场景下，我们并不能保证调整原有代码以后，之前功能不受影响。我们将投入更多的时间进行原有代码功能的回归，这是我们不希望发生的。

这个时候我们就可以使用简单工厂模式。

创建简单工厂`FactoryCell`
```
+ (UITableViewCell *)configUI:(NSInteger)tag withTableView:(UITableView *)tableView{
if (tag == 0) {

OneCell *cell = [tableView dequeueReusableCellWithIdentifier:@"OneCell"];
[cell configUI];  //不同样式的Cell所展示的UI各不相同，由于是Demo样例，这里并未配置相关数据源
return cell;
}else if (tag == 1) {

TwoCell *cell = [tableView dequeueReusableCellWithIdentifier:@"TwoCell"];
[cell configUI];
return cell;
}else if (tag == 2) {

ThreeCell *cell = [tableView dequeueReusableCellWithIdentifier:@"ThreeCell"];
[cell configUI];
return cell;
}

return nil;
}

```

在`UITableView`的代理方法中调用，这个时候`UITableViewCell`变清爽的好多。
```
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{

return [FactoryCell configUI:indexPath.row withTableView:tableView];
}
```
























































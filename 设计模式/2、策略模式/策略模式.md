## 策略模式 
策略模式：她定义了算法家族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户

### 使用场景
- 针对同一个问题的多种不同的处理方式，但是具体的实现有差异，需要实现统一的接口，对变化部分进行封装【面向抽象而非面向具体原则】。
- `分支太多导致了客户端对算法实现类的依赖太大`，算法扩展需要去修改实现--添加对应的分支，使得扩展不方便以及算法类中的代码量膨胀。为了让算法类的扩展容易，需要对具体的算法独立封装【开闭原则】；为了让算法代码保持最小和最简单，需要对具体的算法独立实现【单一职责原则】。


优点：

- 提供了管理相关的算法族的办法。可以封装一些算法，不想让算法直接暴露出来。

- 可以避免使用多重条件转移语句，消除根据类型决定使用什么算法的一些if-else的语句。


策略模式有点类似于代理模式，这两种模式都依赖于某个协议；在代理模式中，遵循了协议的对象就可以成为代理；在策略模式中，遵循了协议的就可以成一个策略。

### 使用案例
我查看网上比较好的使用案例

1、理财产品的回报计算，处理方式是一样的，客户端只要给固定的参数（平台、月份、金额），需要计算出本金及利息的和，不同理财产品的计算接口定义是统一的，在实现上有差别，所以类似这种场景是比较适合使用策略模式的。

- 2、商场打折问题


 ![1](https://github.com/SunshineBrother/JHBlog/blob/master/设计模式/2、策略模式/case.png)

- 1、策略类 定义了所有支持的算法的公共接口
其中`caseSuper`就是抽象策略，`caseOne`，`caseTwo`，`caseThree`就是三个具体的策略，

- 2、context上下文，用一个配置文件维护策略对象的引用


### 代码

下面我来用  `工厂模式`和`策略模式`分别写一个计算器，通过一个案列来给那个方法的对比，让我们更加清晰他们之间的区别









